Ниже — план реализации, архитектура и конкретика по библиотекам/модулям так, чтобы агент мог собрать бота без “дырок” в логике диалогов, данных и записи файлов (Obsidian-friendly markdown).

⸻

0) Цель и основные решения

Хранилище данных: файловая система (папки FoodLog/, Foods/, ConditionLog/) в формате markdown с YAML-frontmatter, как у вас в схеме.
Ключевая часть: надёжная диалоговая машина состояний: “добавляем ингредиенты” → “подтверждаем завершение” → “оценка состояния” → “сохранение”.

Почему так: вам не нужна БД на старте, а Obsidian-структура должна быть детерминированной и устойчивой к конкуренции (два сообщения подряд, повторная отправка, падение процесса).

⸻

1) Стек и библиотеки

Telegram
	•	aiogram v3 — современный async-фреймворк под Telegram Bot API, удобен для FSM и inline клавиатур.
	•	aiofiles — асинхронная запись файлов.
	•	pydantic — модели данных (валидация симптомов, структуры “черновика события”).
	•	python-dotenv — конфиг через .env.
	•	PyYAML (опционально) — если хотите генерировать YAML не руками. Можно и без него (строкой), но библиотека снижает риск кривого YAML.

Инфраструктура/качество
	•	structlog или стандартный logging — структурные логи.
	•	pytest + pytest-asyncio — тесты на генерацию файлов и FSM-переходы.
	•	ruff + mypy (желательно) — статический контроль ошибок.

Будущие интеграции (пока заглушки)
	•	openai (официальный SDK) — разбор блюда → ингредиенты.
	•	OCR: pytesseract + system Tesseract, либо easyocr (как отдельный модуль позже).

⸻

2) Репозиторий и структура кода

Предлагаемая структура (минимально “enterprise”, но без хаоса):

bot/
  app.py
  config.py
  logging_setup.py

  handlers/
    start.py
    add_food.py
    photo.py         # пока заглушка
    common.py

  fsm/
    states.py
    storage.py       # FSM storage (Memory/Redis — опционально)

  domain/
    models.py        # pydantic: FoodEventDraft, Condition, etc.
    normalize.py     # нормализация ингредиентов, slugify/filenames

  services/
    food_event_service.py     # orchestration: draft -> save
    file_store.py             # запись/чтение markdown
    foods_service.py          # ensure Foods/<ingredient>.md
    condition_service.py      # запись ConditionLog
    time_service.py           # now() с TZ, форматирование

  ui/
    keyboards.py      # inline keyboards, callbacks
    callbacks.py      # callback data schemas

  tests/
    test_markdown_render.py
    test_filename_sanitize.py
    test_fsm_flow.py

data/
  FoodLog/
  Foods/
  ConditionLog/

Ключевая идея: handlers не пишут файлы напрямую. Они вызывают сервисы, а сервисы используют file_store. Так вы избежите “спагетти” и упростите тестирование.

⸻

3) Данные и модели (Pydantic)

Черновик события приёма пищи

Храним в FSM контексте “draft”, чтобы переживать несколько сообщений:
	•	started_at (datetime)
	•	foods_raw: list[str] — список введённых строками ингредиентов (ещё не нормализованных)
	•	foods_normalized: list[str] — после нормализации
	•	message_ids (опционально) — если захотите потом чистить чат/редактировать.

Condition
	•	bloating: bool
	•	diarrhea: bool
	•	well_being: int (1..10)

Важно: нормализация ингредиентов

Чтобы ссылки в Obsidian работали стабильно, применяем:
	•	strip()
	•	приводим к нижнему регистру
	•	заменяем множественные пробелы на один
	•	убираем служебные символы
	•	опционально: словарь синонимов (позже)

⸻

4) Правила именования файлов и безопасная запись

Foods/

Вы хотите “файл с именем ингредиента”. На практике нужно sanitize:
	•	запретить / \ : * ? " < > | (Windows-совместимость)
	•	убрать точки в конце имени
	•	ограничить длину (например, 80–120 символов)
	•	на конфликт имён: добавлять суффикс  (2),  (3) либо хэш.

Пример:
"сыр 9% (моцарелла)" → файл сыр 9% (моцарелла).md (после очистки запрещённых).

FoodLog/ и ConditionLog/

Чтобы избежать коллизий, файл лучше называть не только по дате/времени, а с уникальностью:
	•	YYYY-MM-DD_HH-MM-SS_<shortid>.md
где <shortid> — 6–8 символов (например, base32 от uuid).

Так вы не потеряете запись, если два события в одну секунду.

Атомарность записи

Пишите через временный файл и os.replace():
	1.	создать tmp
	2.	записать содержимое
	3.	replace(tmp, target)
Это защищает от частично записанных файлов при падении процесса.

⸻

5) Диалоги и FSM (точные шаги)

Команды
	•	/start — приветствие + кнопки “Добавить еду”, “Отправить фото (скоро)”
	•	/add — сразу начать добавление еды
	•	/cancel — отменить текущий диалог

FSM состояния
	1.	AddingFoods — пользователь шлёт текст (ингредиенты, переносы строк допустимы)
	2.	ConfirmFinish — “Продолжить” / “Завершить” / “Отменить”
	3.	AskConditionBloating — выбрать да/нет/отмена
	4.	AskConditionDiarrhea — выбрать да/нет/отмена
	5.	AskConditionWellBeing — выбрать 1–10/отмена
	6.	Persisting — техническое (можно без явного state)

Логика AddingFoods
	•	Пользователь отправляет текст. Вы:
	•	режете по строкам
	•	фильтруете пустые
	•	добавляете в draft
	•	показываете краткий список (последние N, либо количество)
	•	показываете кнопки: “Продолжить ввод”, “Завершить”, “Отменить”

Почему отдельный ConfirmFinish: пользователь может вводить ингредиенты несколькими сообщениями. Кнопки снимают двусмысленность, когда “ещё один текст” может быть как продолжение, так и новая команда.

Cancel

Отмена должна:
	•	очищать FSM state
	•	подтверждать пользователю, что ничего не записано

⸻

6) Сохранение данных (точный порядок)

После “Завершить”:
	1.	Нормализовать ингредиенты:
	•	для каждого ингредиента получить name_norm
	•	дедуплицировать (set) сохраняя порядок (order-preserving)
	2.	Создать Foods заметки:
	•	для каждого name_norm убедиться, что data/Foods/<name>.md существует
	•	содержимое может быть пустым или иметь минимальный frontmatter (по желанию). Вы писали “схемы нет”, значит достаточно пустого файла или заголовка # <name>.
	3.	Записать FoodLog:
	•	дата/время берутся из “момента завершения” (или started_at — выберите одно правило и придерживайтесь)
	•	YAML:
	•	date: YYYY-MM-DD
	•	time: HH:MM
	•	foods:
	•	- [[ингредиент]]
	4.	Оценка состояния (ConditionLog):
	•	если пользователь в процессе оценки нажал “Отменить” — не пишем ничего (и FoodLog тоже не пишем).
	•	иначе записываем ConditionLog отдельным файлом, с тем же timestamp, что и FoodLog (важно для связки аналитикой).

Важное решение: записывать FoodLog до ConditionLog или после?
Рекомендую: писать оба файла только после завершения оценки состояния, чтобы отмена гарантированно не оставляла “полузапись”. Для этого всё держим в draft.

⸻

7) Формирование markdown (строго под ваши схемы)

FoodLog заметка

---
date: 2025-03-12
time: 19:30
foods:
  - [[паста]]
  - [[сыр]]
  - [[молоко]]
---

ConditionLog заметка

У вас в примере нет открывающего ---, но в YAML-frontmatter он должен быть. Делайте так:

---
date: 2025-03-12
time: 19:30
symptoms:
  bloating: true
  diarrhea: false
  well_being: 6
---


⸻

8) Параллелизм, идемпотентность, защита от “двойных кликов”

Типовые проблемы телеграм-ботов:
	•	пользователь нажал кнопку дважды
	•	Telegram переотправил update
	•	два сообщения пришли почти одновременно

Решение:
	•	На “завершить” и на каждом callback проверяйте текущий state и наличие draft-полей.
	•	В момент сохранения используйте уникальные имена файлов.
	•	В aiogram можно добавлять middleware-лок на пользователя (per-user lock), чтобы обработчики одного user_id не выполнялись параллельно.

⸻

9) Заглушка под “фото → блюдо/состав” (без реализации сейчас)

Сразу заложите интерфейс:

services/photo_intake.py
	•	classify_image(image_bytes) -> Literal["dish", "ingredients"]
	•	dish_to_ingredients(image_bytes) -> list[str] (OpenAI)
	•	ocr_ingredients(image_bytes) -> list[str] (OCR)

Handlers:
	•	принимают фото
	•	пока отвечают: “Функция в разработке. Временно вставляйте результат текстом через /add”.

Так вы потом добавите реализацию, не ломая FSM.

⸻

10) Конфигурация

.env:
	•	BOT_TOKEN=...
	•	DATA_DIR=./data
	•	TZ=Europe/Riga

config.py читает env, валидирует наличие токена, нормализует пути.

⸻

11) Тесты (минимальный набор, который реально ловит ошибки)
	1.	test_filename_sanitize.py
	•	запрещённые символы
	•	длинные строки
	•	одинаковые имена → корректный resolve коллизий
	2.	test_markdown_render.py
	•	корректный YAML (поля, отступы, true/false, список foods)
	3.	test_fsm_flow.py (pytest-asyncio)
	•	имитация: /add → текст1 → “продолжить” → текст2 → “завершить” → симптомы → сохранено два файла
	•	сценарий отмены на симптомах → файлов нет

⸻

12) Пошаговый план реализации (чтобы агент не ошибся)
	1.	Инициализировать проект (poetry/uv/pip — как вам удобно), добавить зависимости.
	2.	Реализовать config.py, logging_setup.py, app.py (aiogram Dispatcher, Router).
	3.	Реализовать domain/models.py + domain/normalize.py (sanitize + normalize).
	4.	Реализовать services/file_store.py (атомарная запись, ensure_dir).
	5.	Реализовать services/foods_service.py (ensure note exists).
	6.	Реализовать services/food_event_service.py:
	•	собрать draft → нормализовать → подготовить markdown тексты → сохранить оба файла
	7.	FSM:
	•	fsm/states.py
	•	handlers /add, текстовые сообщения, callbacks (продолжить/завершить/отмена), симптомы.
	8.	UI клавиатуры: ui/keyboards.py, ui/callbacks.py (строгие callback_data схемы).
	9.	Добавить /cancel, обработчик “неожиданного текста” вне FSM (подсказка).
	10.	Написать тесты на sanitize/markdown/FSM.
	11.	Ручная проверка: локальный запуск, ввод нескольких ингредиентов, отмена, повторное добавление, просмотр файлов в Obsidian.
	12.	Подготовить “photo pipeline” как заглушку интерфейса (без реальной интеграции).

⸻

Если хотите, я могу сразу выдать “скелет” проекта: файлы app.py, роутеры aiogram v3, FSM states, сервисы записи markdown и нормализацию ингредиентов — так, чтобы вы только вставили токен и запустили.
